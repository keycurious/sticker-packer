<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Sticker Packer</title>
    <style>
           :root{
            --kc-bg:#1b1c1f;
            --kc-bg-2:#26272b;
            --kc-card:#ffffff;
            --kc-ink:#e9ecef;
            --kc-grad-start:#ff2d8d; /* magenta */
            --kc-grad-end:#ff8a00;   /* orange */
            --kc-accent:#ff6a00;
            --kc-border:#2f3136;
            --kc-muted:#8a8f98;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(1200px 600px at 20% -10%, #222328 0%, var(--kc-bg) 60%, #0f1012 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header-inner{
            display:flex;
            align-items:center;
            justify-content:center;
            gap:16px;
            flex-wrap:wrap;
        }
        .brand-logo{
            width:56px;
            height:56px;
        }
        .header h1 {
            font-size: 2.25rem;
            margin-bottom: 4px;
            line-height: 1.1;
            text-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }
        .brand-gradient{
            background: linear-gradient(45deg, var(--kc-grad-start), var(--kc-grad-end));
            -webkit-background-clip:text;
            background-clip:text;
            color: transparent;
        }
        .header p{
            color: var(--kc-ink);
            opacity:.9;
        }

        .main-content {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #fbfbfd;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #eef0f3;
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #374151;
            font-size: 1.1rem;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: block;
            padding: 12px 20px;
            background: linear-gradient(45deg, var(--kc-grad-start), var(--kc-grad-end));
            color: white;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.25s ease;
            font-weight: 600;
            letter-spacing:.2px;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 74, 0, 0.25);
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #374151;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: var(--kc-accent);
            box-shadow: 0 0 0 3px rgba(255,106,0,0.15);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700;
            letter-spacing:.2px;
            transition: transform 0.25s ease, box-shadow 0.25s ease, opacity 0.25s ease;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(45deg, var(--kc-grad-start), var(--kc-grad-end));
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4b5563, #1f2937);
            color: white;
        }

        .btn-download {
            background: linear-gradient(45deg, var(--kc-grad-end), var(--kc-grad-start));
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 18px rgba(0,0,0,0.25);
        }

        .preview-area {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }

        .stickers-list {
            flex: 1;
            max-width: 300px;
        }

        .stickers-list h3 {
            margin-bottom: 15px;
            color: #374151;
        }

        .sticker-item {
            background: #fbfbfd;
            border: 2px solid #eef0f3;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
        }

        .sticker-remove-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .sticker-remove-btn:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        .sticker-quantity {
            background: linear-gradient(45deg, var(--kc-grad-start), var(--kc-grad-end));
            color: white;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 700;
            margin-top: 4px;
        }

        .sticker-preview {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            object-fit: contain;
            background: white;
            border: 1px solid #e5e7eb;
        }

        .sticker-info {
            flex: 1;
        }

        .sticker-info h4 {
            margin-bottom: 5px;
            color: #111827;
        }

        .sticker-info p {
            font-size: 12px;
            color: #6b7280;
        }

        .canvas-container {
            flex: 2;
            background: white;
            border-radius: 14px;
            padding: 20px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.12);
            text-align: center;
        }

        .canvas-container h3 {
            margin-bottom: 15px;
            color: #374151;
        }

        #packingCanvas {
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            max-width: 100%;
            height: auto;
            background: white;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 10px;
            font-weight: 600;
        }

        .status.success {
            background: linear-gradient(90deg, #e8f8ee, #f0fff4);
            color: #166534;
            border: 1px solid #bbf7d0;
        }

        .status.info {
            background: linear-gradient(90deg, #eef2ff, #f5f3ff);
            color: #3730a3;
            border: 1px solid #c7d2fe;
        }

        .status.warning {
            background: linear-gradient(90deg, #fff7ed, #fff1f2);
            color: #7c2d12;
            border: 1px solid #fed7aa;
        }

        .efficiency-meter {
            margin-top: 15px;
            background: #fbfbfd;
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #eef0f3;
        }

        .efficiency-bar {
            width: 100%;
            height: 20px;
            background: #eef0f3;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 8px;
        }

        .intelligence-slider {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 6px;
            background: linear-gradient(90deg, var(--kc-grad-start), var(--kc-grad-end));
            outline: none;
        }

        .intelligence-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--kc-grad-start);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            border: 2px solid white;
        }

        .intelligence-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--kc-grad-start);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .intelligence-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #6b7280;
        }

        .efficiency-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--kc-grad-start), var(--kc-grad-end));
            border-radius: 12px;
            transition: width 0.3s ease;
        }

        /* Sponsor banner */
        .sponsor-banner {
            display: block;
            text-decoration: none;
            margin-top: 28px;
        }
        .sponsor-inner {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px 18px;
            border-radius: 16px;
            border: 2px solid #eef0f3;
            background: linear-gradient(90deg, rgba(255,45,141,0.08), rgba(255,138,0,0.08));
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .sponsor-inner:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.12);
        }
        .sponsor-logo{
            width:40px;
            height:40px;
        }
        .sponsor-badge {
            font-size: 12px;
            font-weight: 700;
            color: #374151;
            background: #f3f4f6;
            border-radius: 999px;
            padding: 4px 10px;
        }
        .sponsor-text {
            flex: 1;
            color: #ff2d8d;
        }
        .sponsor-text strong {
            display: block;
            color: #ff8a00;
        }
        .sponsor-cta {
            font-weight: 800;
            background: linear-gradient(45deg, var(--kc-grad-start), var(--kc-grad-end));
            -webkit-background-clip:text;
            background-clip:text;
            color: transparent;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
             <h1><span class="brand-gradient">KeyCurious</span> Smart Sticker Packer🏷️ </h1>
                    <p>Die‑Cut Sticker Layout Optimizer</p>
        </div>

        <div class="main-content">
            <div class="controls">
                <div class="control-group">
                    <h3>📁 Upload Stickers</h3>
                    <div class="input-group">
                        <label>Default Size (mm)</label>
                        <input type="number" id="defaultStickerSize" value="60" min="5" max="100">
                    </div>
                    <div class="file-input-wrapper">
                        <input type="file" id="stickerFiles" class="file-input" multiple accept="image/*">
                        <label for="stickerFiles" class="file-input-label">
                            Add Sticker Files
                        </label>
                    </div>
                    <button class="btn btn-secondary" onclick="clearAllStickers()" style="width: 100%; margin-top: 10px;">
                        🗑️ Clear All Stickers
                    </button>
                </div>

                <div class="control-group">
                <h3>📏 Sheet Settings</h3>
                <div class="input-group">
                    <label>Paper Size</label>
                    <select id="paperSizeSelect">
                        <option value="a4">A4 (210 × 297 mm)</option>
                        <option value="a3">A3 (297 × 420 mm)</option>
                        <option value="a5">A5 (148 × 210 mm)</option>
                        <option value="letter">Letter (216 × 279 mm)</option>
                        <option value="legal">Legal (216 × 356 mm)</option>
                        <option value="tabloid">Tabloid (279 × 432 mm)</option>
                        <option value="4x6">Photo 4×6" (102 × 152 mm)</option>
                        <option value="5x7">Photo 5×7" (127 × 178 mm)</option>
                        <option value="8x10">Photo 8×10" (203 × 254 mm)</option>
                        <option value="11x14">Photo 11×14" (279 × 356 mm)</option>
                        <option value="custom">Custom Size</option>
                    </select>
                </div>
                <div class="input-group" id="customSizeInputs" style="display: none;">
                    <label>Width (mm)</label>
                    <input type="number" id="customWidth" value="210" min="50" max="1000">
                    <label>Height (mm)</label>
                    <input type="number" id="customHeight" value="297" min="50" max="1000">
                </div>
                <div class="input-group">
                    <label>Resolution (DPI)</label>
                    <select id="dpiSelect">
                        <option value="300">300 DPI (Standard)</option>
                        <option value="600">600 DPI (High Quality)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Margin (mm)</label>
                    <input type="number" id="marginInput" value="5" min="0" max="20">
                </div>
            </div>

                <div class="control-group">
                    <h3>⚙️ Packing Options</h3>
                    <div class="input-group">
                        <label>Intelligence Level</label>
                        <input type="range" id="intelligenceSlider" min="1" max="5" value="3" class="intelligence-slider">
                        <div class="intelligence-labels">
                            <span>🚀 Fast</span>
                            <span id="intelligenceLabel">⚡ Balanced</span>
                            <span>🧠 Smart</span>
                        </div>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="allowRotation" checked>
                        <label>Allow Rotation</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="tightPacking" checked>
                        <label>Tight Packing</label>
                    </div>
                    <div class="checkbox-group">
                         <input type="checkbox" id="allowFlip">
                         <label>Allow Mirroring (Flip)</label>
                    </div>
                    <div class="control-group">
                    <h3>✂️ Cutline</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showCutline" checked>
                        <label>Show Cutline</label>
                    </div>

                    <div class="input-group">
                        <label>Cutline Thickness (mm)</label>
                        <input type="number" id="cutlineWidthMM" min="0" step="0.1" value="1.0">
                    </div>

                    <div class="input-group">
                        <label>Cutline Color</label>
                        <input type="color" id="cutlineColor" value="#ff00ff">
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="transparentExport" checked>
                        <label>PNG Export Transparent Background</label>
                    </div>
                    </div>

                    <div class="input-group">
                        <label>Algorithm</label>
                        <select id="algorithmSelect">
                            <option value="bottomLeft">Bottom-Left Fill</option>
                            <option value="bestFit">Best Fit</option>
                            <option value="genetic">Genetic Algorithm</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" onclick="packStickers()">🧩 Auto Pack Stickers</button>
                <button class="btn btn-secondary" onclick="clearAll()">🗑️ Clear All</button>
                <button class="btn btn-download" onclick="downloadPNG()" id="downloadBtn" disabled>💾 Download PNG</button>
            </div>

            <div class="preview-area">
                <div class="stickers-list">
                    <h3>📋 Loaded Stickers</h3>
                    <div id="stickersList"></div>
                </div>

                <div class="canvas-container">
                    <h3>🎯 A4 Sheet Preview</h3>
                    <canvas id="packingCanvas" width="595" height="842"></canvas>
                    
                    <div class="efficiency-meter">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span><strong>Space Efficiency:</strong></span>
                            <span id="efficiencyText">0%</span>
                        </div>
                        <div class="efficiency-bar">
                            <div class="efficiency-fill" id="efficiencyFill" style="width: 0%"></div>
                        </div>
                    </div>

                    <div id="statusMessage" class="status info">
                        Upload sticker images to begin auto-packing
                    </div>
                </div>
            </div>
        </div>
        <a class="sponsor-banner" 
        href="https://keycurious.etsy.com" 
        target="_blank" rel="noopener noreferrer" aria-label="Visit our Etsy shop">
        <div class="sponsor-inner">
            <div class="sponsor-badge">Sponsor</div>
            <div class="sponsor-text">
            <strong>Love this tool?</strong>
            <span>Check out our die‑cut stickers on Etsy</span>
            </div>
            <div class="sponsor-cta">Visit Shop →</div>
        </div>
        </a>
    </div>

    <script>
        class StickerPacker {
            constructor() {
                this.stickers = [];
                this.packedStickers = [];
                this.canvas = document.getElementById('packingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.dpi = 300;
                this.margin = 5; // mm
                this.stickerIdCounter = 1;
                
                // Paper sizes in mm (width × height)
                this.paperSizes = {
                    a4: { width: 210, height: 297, name: 'A4' },
                    a3: { width: 297, height: 420, name: 'A3' },
                    a5: { width: 148, height: 210, name: 'A5' },
                    letter: { width: 216, height: 279, name: 'Letter' },
                    legal: { width: 216, height: 356, name: 'Legal' },
                    tabloid: { width: 279, height: 432, name: 'Tabloid' },
                    '4x6': { width: 102, height: 152, name: '4×6"' },
                    '5x7': { width: 127, height: 178, name: '5×7"' },
                    '8x10': { width: 203, height: 254, name: '8×10"' },
                    '11x14': { width: 279, height: 356, name: '11×14"' },
                    custom: { width: 210, height: 297, name: 'Custom' }
                };
                
                // Current paper dimensions
                this.currentPaper = this.paperSizes.a4;
                
                this.setupEventListeners();
                this.updateCanvasSize();
            }

            setupEventListeners() {
                document.getElementById('stickerFiles').addEventListener('change', (e) => {
                    this.loadStickers(e.target.files);
                });

                document.getElementById('paperSizeSelect').addEventListener('change', (e) => {
                    const selectedSize = e.target.value;
                    const customInputs = document.getElementById('customSizeInputs');
                    
                    if (selectedSize === 'custom') {
                        customInputs.style.display = 'block';
                        this.currentPaper = {
                            width: parseInt(document.getElementById('customWidth').value),
                            height: parseInt(document.getElementById('customHeight').value),
                            name: 'Custom'
                        };
                    } else {
                        customInputs.style.display = 'none';
                        this.currentPaper = this.paperSizes[selectedSize];
                    }
                    this.updateCanvasSize();
                    this.updateHeaderTitle();
                });

                document.getElementById('customWidth').addEventListener('change', (e) => {
                    this.currentPaper.width = parseInt(e.target.value);
                    this.updateCanvasSize();
                });

                document.getElementById('customHeight').addEventListener('change', (e) => {
                    this.currentPaper.height = parseInt(e.target.value);
                    this.updateCanvasSize();
                });

                document.getElementById('dpiSelect').addEventListener('change', (e) => {
                    this.dpi = parseInt(e.target.value);
                    this.updateCanvasSize();
                });

                document.getElementById('marginInput').addEventListener('change', (e) => {
                    this.margin = parseInt(e.target.value);
                    this.updateCanvasSize();
                });

                // Intelligence slider
                document.getElementById('intelligenceSlider').addEventListener('input', (e) => {
                    this.updateIntelligenceLabel(parseInt(e.target.value));
                });
            }

            updateIntelligenceLabel(level) {
                const labels = {
                    1: '🚀 Lightning Fast',
                    2: '⚡ Fast & Smart',
                    3: '⚖️ Balanced',
                    4: '🧠 Intelligent',
                    5: '🎯 Maximum Precision'
                };
                document.getElementById('intelligenceLabel').textContent = labels[level];
            }

            updateHeaderTitle() {
                const previewTitle = document.querySelector('.canvas-container h3');
                if (previewTitle) {
                    previewTitle.textContent = `🎯 ${this.currentPaper.name} Sheet Preview`;
                }
            }

            updateCanvasSize() {
                const pixelsPerMM = this.dpi / 25.4;
                const canvasWidth = this.currentPaper.width * pixelsPerMM;
                const canvasHeight = this.currentPaper.height * pixelsPerMM;
                
                this.canvas.width = canvasWidth;
                this.canvas.height = canvasHeight;
                
                // Scale for display
                const displayScale = Math.min(500 / canvasWidth, 700 / canvasHeight);
                this.canvas.style.width = (canvasWidth * displayScale) + 'px';
                this.canvas.style.height = (canvasHeight * displayScale) + 'px';
                
                this.drawA4Background();

            }

            updateStickerInList(sticker) {
                const item = document.getElementById(`sticker-item-${sticker.id}`);
                if (item) {
                    const quantityEl = item.querySelector('.sticker-quantity');
                    if (quantityEl) {
                        quantityEl.textContent = `Qty: ${sticker.quantity}`;
                    }
                }
            }

            drawA4Background(ctx = this.ctx) {
            // White preview background only; export can call renderPackedStickers(false, ...)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            const marginPx = this._mmToPx(this.margin);
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(
                marginPx, marginPx,
                this.canvas.width - 2 * marginPx,
                this.canvas.height - 2 * marginPx
            );
            ctx.setLineDash([]);
            }


            async loadStickers(files) {
            const stickersList = document.getElementById('stickersList');
            const defaultSize = parseInt(document.getElementById('defaultStickerSize').value);
            let addedCount = 0;

            for (const file of files) {
                try {
                    // Check if sticker with same name already exists
                    const existingSticker = this.stickers.find(s => s.name === file.name);
                    
                    if (existingSticker) {
                        // Increase quantity instead of adding duplicate
                        existingSticker.quantity = (existingSticker.quantity || 1) + 1;
                        this.updateStickerInList(existingSticker);
                    } else {
                        // Add new sticker
                        const sticker = await this.processSticker(file, defaultSize);
                        sticker.quantity = 1;
                        this.stickers.push(sticker);
                        this.addStickerToList(sticker);
                        addedCount++;
                    }
                } catch (error) {
                    console.error('Error processing sticker:', error);
                }
            }

            if (addedCount > 0) {
                this.updateStatus(`Added ${addedCount} new stickers to inventory`, 'success');
            } else {
                this.updateStatus(`Updated quantities for existing stickers`, 'info');
            }
            
            // Clear the file input so same files can be added again
            document.getElementById('stickerFiles').value = '';
        }

            async processSticker(file, defaultSize = 60) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        const bounds = this.getAlphaBounds(ctx, img.width, img.height);
                        
                        const sticker = {
                            id: this.stickerIdCounter++,
                            name: file.name,
                            originalImage: img,
                            bounds: bounds,
                            width: bounds.width,
                            height: bounds.height,
                            area: bounds.width * bounds.height,
                            alphaMask: this.createAlphaMask(ctx, bounds, img.width, img.height),
                            // Add simplified shape for ultra-fast collision
                            shape: 'rectangle', // Simplified - treat all as rectangles for speed
                            defaultSizeMM: defaultSize,
                            quantity: 1
                        };

                        resolve(sticker);
                    };

                    img.onerror = reject;
                    img.src = URL.createObjectURL(file);
                });
            }

            getAlphaBounds(ctx, width, height) {
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                let minX = width, minY = height, maxX = 0, maxY = 0;
                let hasAlpha = false;

                // Intelligence-based sampling
                const intelligence = parseInt(document.getElementById('intelligenceSlider')?.value || 3);
                const step = intelligence <= 2 ? 8 : intelligence === 3 ? 4 : intelligence === 4 ? 2 : 1;
                const alphaThreshold = intelligence <= 2 ? 200 : intelligence === 3 ? 128 : intelligence === 4 ? 64 : 32;

                for (let y = 0; y < height; y += step) {
                    for (let x = 0; x < width; x += step) {
                        const alpha = data[(y * width + x) * 4 + 3];
                        if (alpha > alphaThreshold) {
                            hasAlpha = true;
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }

                if (!hasAlpha) {
                    return { x: 0, y: 0, width: width, height: height };
                }

                const padding = intelligence <= 2 ? 4 : intelligence === 3 ? 2 : 1;
                return {
                    x: Math.max(0, minX - padding),
                    y: Math.max(0, minY - padding),
                    width: Math.min(width, maxX - minX + padding * 2),
                    height: Math.min(height, maxY - minY + padding * 2)
                };
            }
            
                        // Add this method somewhere inside the StickerPacker class
           // Inside class StickerPacker
            fastCollisionCheck(x, y, width, height, placed) {
            for (const o of placed) {
                if (x < o.x + o.finalWidth && x + width > o.x &&
                    y < o.y + o.finalHeight && y + height > o.y) {
                return false; // collision
                }
            }
            return true; // no collision
            }

            rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
            return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
            }

            // AABB collision scan that ignores a specific id
            fastCollisionCheckExcept(x, y, width, height, placed, excludeId) {
            for (const o of placed) {
                if (excludeId != null && o.id === excludeId) continue;
                if (this.rectsOverlap(x, y, width, height, o.x, o.y, o.finalWidth, o.finalHeight)) {
                return false;
                }
            }
            return true;
            }
            
            compactLayout(placed, maxWidth, maxHeight) {
            let moved = true;
            const maxIter = 3; // keep it quick; increase if you want even tighter
            let iter = 0;

            while (moved && iter < maxIter) {
                moved = false;
                iter++;

                for (const s of placed) {
                // Slide LEFT
                let nx = s.x;
                while (nx > 0 &&
                        this.fastCollisionCheckExcept(nx - 1, s.y, s.finalWidth, s.finalHeight, placed, s.id)) {
                    nx--;
                }
                if (nx !== s.x) { s.x = nx; moved = true; }

                // Slide DOWN
                let ny = s.y;
                while (ny > 0 &&
                        this.fastCollisionCheckExcept(s.x, ny - 1, s.finalWidth, s.finalHeight, placed, s.id)) {
                    ny--;
                }
                if (ny !== s.y) { s.y = ny; moved = true; }

                // Clamp to bounds
                s.x = Math.max(0, Math.min(s.x, maxWidth  - s.finalWidth));
                s.y = Math.max(0, Math.min(s.y, maxHeight - s.finalHeight));
                }
            }
            }


            createAlphaMask(ctx, bounds, imgWidth, imgHeight) {
                const intelligence = parseInt(document.getElementById('intelligenceSlider')?.value || 3);
                
                if (intelligence <= 2) {
                    // Fast mode: just rectangles
                    return {
                        type: 'rectangle',
                        width: bounds.width,
                        height: bounds.height
                    };
                } else if (intelligence === 3) {
                    // Balanced: simplified convex hull
                    const points = [];
                    const imageData = ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
                    const data = imageData.data;
                    
                    const step = Math.max(2, Math.floor(Math.min(bounds.width, bounds.height) / 15));
                    
                    for (let y = 0; y < bounds.height; y += step) {
                        for (let x = 0; x < bounds.width; x += step) {
                            const alpha = data[(y * bounds.width + x) * 4 + 3];
                            if (alpha > 100) {
                                points.push({x, y});
                            }
                        }
                    }
                    
                    return {
                        type: 'polygon',
                        width: bounds.width,
                        height: bounds.height,
                        points: points.slice(0, 50)
                    };
                } else {
                    // High intelligence: detailed shape analysis
                    const points = [];
                    const imageData = ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
                    const data = imageData.data;
                    
                    const step = intelligence === 4 ? 2 : 1;
                    
                    for (let y = 0; y < bounds.height; y += step) {
                        for (let x = 0; x < bounds.width; x += step) {
                            const alpha = data[(y * bounds.width + x) * 4 + 3];
                            if (alpha > 50) {
                                points.push({x, y});
                            }
                        }
                    }
                    
                    return {
                        type: 'detailed',
                        width: bounds.width,
                        height: bounds.height,
                        points: points.slice(0, intelligence === 4 ? 200 : 500)
                    };
                }
            }

            addStickerToList(sticker) {
                const stickersList = document.getElementById('stickersList');
                const item = document.createElement('div');
                item.className = 'sticker-item';
                item.id = `sticker-item-${sticker.id}`;
                
                // Create preview canvas
                const previewCanvas = document.createElement('canvas');
                previewCanvas.width = 60;
                previewCanvas.height = 60;
                previewCanvas.className = 'sticker-preview';
                
                const previewCtx = previewCanvas.getContext('2d');
                const scale = Math.min(60 / sticker.width, 60 / sticker.height);
                const drawWidth = sticker.width * scale;
                const drawHeight = sticker.height * scale;
                const offsetX = (60 - drawWidth) / 2;
                const offsetY = (60 - drawHeight) / 2;
                
                previewCtx.drawImage(
                    sticker.originalImage,
                    sticker.bounds.x, sticker.bounds.y, sticker.bounds.width, sticker.bounds.height,
                    offsetX, offsetY, drawWidth, drawHeight
                );

                item.innerHTML = `
                    <button class="sticker-remove-btn" onclick="removeSticker(${sticker.id})" title="Remove sticker">×</button>
                    <div class="sticker-info">
                        <h4>${sticker.name}</h4>
                        <p>Size: ${sticker.width} × ${sticker.height}px</p>
                        <div class="sticker-quantity">Qty: ${sticker.quantity}</div>
                        <div class="input-group" style="margin-top: 8px;">
                            <label style="font-size: 11px;">Height (mm):</label>
                            <input type="number" value="${sticker.defaultSizeMM}" min="5" max="100" 
                                onchange="updateStickerSize(${sticker.id}, this.value)"
                                style="padding: 4px; font-size: 12px;">
                        </div>
                        <div style="display: flex; gap: 5px; margin-top: 5px;">
                            <button class="btn" style="padding: 2px 8px; font-size: 11px; background: #10b981; color: white;" 
                                    onclick="adjustQuantity(${sticker.id}, 1)">+</button>
                            <button class="btn" style="padding: 2px 8px; font-size: 11px; background: #ef4444; color: white;" 
                                    onclick="adjustQuantity(${sticker.id}, -1)">−</button>
                        </div>
                    </div>
                `;
                
                item.insertBefore(previewCanvas, item.firstChild);
                stickersList.appendChild(item);
            }

             packStickers() {
                if (this.stickers.length === 0) {
                    this.updateStatus('Please upload stickers first', 'warning');
                    return;
                }

                const algorithm = document.getElementById('algorithmSelect').value;
                const allowRotation = document.getElementById('allowRotation').checked;
                const tightPacking = document.getElementById('tightPacking').checked;
                const allowFlip = document.getElementById('allowFlip').checked;

                this.updateStatus('Packing stickers...', 'info');

                setTimeout(() => {
                    try {
                    this.packedStickers = this.executePackingAlgorithm(
                        algorithm, allowRotation, tightPacking, allowFlip
                    );
                    this.renderPackedStickers();
                    this.calculateEfficiency();
                    this.updateStatus(`Successfully packed ${this.packedStickers.length} stickers`, 'success');
                    document.getElementById('downloadBtn').disabled = false;
                    } catch (error) {
                    this.updateStatus('Packing failed: ' + error.message, 'warning');
                    }
                }, 100);
                }

                executePackingAlgorithm(algorithm, allowRotation, tightPacking, allowFlip) {
                    const marginPx = (this.margin * this.dpi) / 25.4;
                    const availableWidth  = this.canvas.width  - 2 * marginPx;
                    const availableHeight = this.canvas.height - 2 * marginPx;

                    // Expand stickers based on quantity
                    const stickersToPlace = [];
                    for (const sticker of this.stickers) {
                        const heightMM = this.getStickerHeightMM(sticker.id);
                        const scale = (heightMM * this.dpi / 25.4) / sticker.height;
                        
                        // Add multiple copies based on quantity
                        for (let i = 0; i < (sticker.quantity || 1); i++) {
                            stickersToPlace.push({
                                ...sticker,
                                id: `${sticker.id}_${i}`, // Unique ID for each copy
                                scaledWidth:  Math.ceil(sticker.width  * scale),
                                scaledHeight: Math.ceil(sticker.height * scale),
                                scale
                            });
                        }
                    }

                // Different sorting strategies
                if (algorithm === 'bottomLeft') {
                    stickersToPlace.sort((a,b) => (b.scaledWidth * b.scaledHeight) - (a.scaledWidth * a.scaledHeight)); // Area
                } else if (algorithm === 'bestFit') {
                    stickersToPlace.sort((a,b) => Math.max(b.scaledWidth, b.scaledHeight) - Math.max(a.scaledWidth, a.scaledHeight)); // Max dimension
                } else if (algorithm === 'genetic') {
                    // Random shuffle for genetic approach
                    for (let i = stickersToPlace.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [stickersToPlace[i], stickersToPlace[j]] = [stickersToPlace[j], stickersToPlace[i]];
                    }
                }

                const placed = [];
                for (const sticker of stickersToPlace) {
                    const position = this.findBestPositionByAlgorithm(
                        sticker, placed, availableWidth, availableHeight,
                        allowRotation, tightPacking, allowFlip, algorithm
                    );
                    if (position) {
                        placed.push({
                            ...sticker,
                            x: position.x,
                            y: position.y,
                            rotation: position.rotation || 0,
                            flip: position.flip || 'none',
                            finalWidth: position.width,
                            finalHeight: position.height
                        });
                    }
                }
                
                this.compactLayout(placed, availableWidth, availableHeight);
                return placed;
            }

                findBestPositionByAlgorithm(sticker, placed, maxWidth, maxHeight, allowRotation, tightPacking, allowFlip, algorithm) {
                const intelligence = parseInt(document.getElementById('intelligenceSlider')?.value || 3);
                const rotations = allowRotation ? [0, 90, 180, 270] : [0];
                const flips = allowFlip ? ['none', 'h', 'v'] : ['none'];
                
                let step, fitnessFunc;
                
                // Different strategies per algorithm
                if (algorithm === 'bottomLeft') {
                    step = 10;
                    fitnessFunc = (x, y, w, h) => y * 1000 + x; // Bottom-left priority
                } else if (algorithm === 'bestFit') {
                    step = 5;
                    fitnessFunc = (x, y, w, h) => {
                        // Find tightest fit next to existing stickers
                        let minGap = Infinity;
                        for (const other of placed) {
                            const gapX = Math.abs(x - (other.x + other.finalWidth));
                            const gapY = Math.abs(y - (other.y + other.finalHeight));
                            minGap = Math.min(minGap, gapX + gapY);
                        }
                        return minGap === Infinity ? (y * 1000 + x) : minGap * 100 + y + x;
                    };
                } else if (algorithm === 'genetic') {
                    step = Math.max(2, Math.floor(Math.random() * 15)); // Random step size
                    fitnessFunc = (x, y, w, h) => {
                        // Random with slight bottom-left bias
                        return Math.random() * 1000 + (y + x) * 0.1;
                    };
                }

                let best = null;

                for (const rotation of rotations) {
                    const { width: baseW, height: baseH } = this.getRotatedDimensions(sticker.scaledWidth, sticker.scaledHeight, rotation);

                    for (const flip of flips) {
                        const width = baseW;
                        const height = baseH;

                        if (width > maxWidth || height > maxHeight) continue;

                        for (let y = 0; y <= maxHeight - height; y += step) {
                            for (let x = 0; x <= maxWidth - width; x += step) {
                                if (this.checkCollisionByIntelligence(x, y, width, height, placed, sticker, intelligence, rotation, flip)) {
                                    const fitness = fitnessFunc(x, y, width, height);
                                    const candidate = { x, y, width, height, rotation, flip, fitness };
                                    if (!best || candidate.fitness < best.fitness) best = candidate;
                                }
                            }
                        }
                    }
                }

                return best;
            }



                findBestPosition(sticker, placed, occupied, maxWidth, maxHeight,
                                allowRotation, tightPacking, allowFlip) {
                const intelligence = parseInt(document.getElementById('intelligenceSlider')?.value || 3);

                const rotations = allowRotation
                    ? (intelligence <= 2 ? [0, 90] : intelligence === 3 ? [0, 90, 180] : [0, 90, 180, 270])
                    : [0];

                const flips = allowFlip ? ['none', 'h', 'v'] : ['none'];

                // Finer step = denser search = better fit
                const step = intelligence <= 2 ? 20
                            : intelligence === 3 ? 10
                            : (tightPacking ? 2 : 3);

                let best = null;

                for (const rotation of rotations) {
                    const { width: baseW, height: baseH } =
                    this.getRotatedDimensions(sticker.scaledWidth, sticker.scaledHeight, rotation);

                    for (const flip of flips) {
                    const width = baseW;  // AABB size; flip doesn't change it
                    const height = baseH;

                    if (width > maxWidth || height > maxHeight) continue;

                    for (let y = 0; y <= maxHeight - height; y += step) {
                        for (let x = 0; x <= maxWidth - width; x += step) {
                        if (this.checkCollisionByIntelligence(
                                x, y, width, height, placed, sticker, intelligence, rotation, flip)) {

                            const fitness = (intelligence <= 2)
                            ? (y * 1000 + x) // bottom-left
                            : this.calculateAdvancedFitness(x, y, width, height, placed, intelligence);

                            const candidate = { x, y, width, height, rotation, flip, fitness };
                            if (!best || candidate.fitness < best.fitness) best = candidate;
                        }
                        }
                    }
                    }
                }

                return best; // null if nothing fits
                }


            checkCollisionByIntelligence(x, y, width, height, placed, sticker, intelligence, rotation, flip) {
                if (intelligence <= 2) {
                    return this.fastCollisionCheck(x, y, width, height, placed);
                } else if (intelligence === 3) {
                    return this.mediumCollisionCheck(x, y, width, height, placed, sticker);
                } else {
                    return this.preciseCollisionCheck(x, y, width, height, placed, sticker, rotation, flip);
                }
                }

            mediumCollisionCheck(x, y, width, height, placed, sticker) {
                // Rectangle check first (fast)
                if (!this.fastCollisionCheck(x, y, width, height, placed)) {
                    return false;
                }
                
                // Add some shape-aware spacing
                const buffer = 5;
                return this.fastCollisionCheck(x - buffer, y - buffer, width + buffer*2, height + buffer*2, placed);
            }

            preciseCollisionCheck(x, y, width, height, placed, sticker, rotation, flip) {
                // 1) AABB must be clear
                if (!this.fastCollisionCheck(x, y, width, height, placed)) return false;

                // 2) Safety gap (kerf). Use a small gap even in tight mode.
                const kerfMM = document.getElementById('tightPacking').checked ? 0.5 : 1.0;
                const pad = (kerfMM * this.dpi) / 25.4;
                if (!this.fastCollisionCheck(x - pad, y - pad, width + 2*pad, height + 2*pad, placed)) return false;

                // 3) (Optional) extra shape sampling with scaled + rotated + flipped points.
                //    Safe to skip for speed; keep it to reduce micro gaps.
                for (const other of placed) {
                    if (this.sampleMasksOverlap(
                    { x, y, width, height, rotation: rotation || 0, flip: flip || 'none',
                        mask: sticker.alphaMask, preRotWidth: sticker.scaledWidth, preRotHeight: sticker.scaledHeight },
                    { x: other.x, y: other.y, width: other.finalWidth, height: other.finalHeight,
                        rotation: other.rotation || 0, flip: other.flip || 'none',
                        mask: other.alphaMask, preRotWidth: other.scaledWidth, preRotHeight: other.scaledHeight }
                    )) {
                    return false;
                    }
                }
                return true;
                }

             sampleMasksOverlap(a, b) {
                // quick reject: bounding boxes don’t overlap
                if (a.x >= b.x + b.width || a.x + a.width <= b.x ||
                    a.y >= b.y + b.height || a.y + a.height <= b.y) {
                    return false;
                }

                // If any mask is missing or rectangle, treat box overlap as collision.
                if (!a.mask || !b.mask || a.mask.type === 'rectangle' || b.mask.type === 'rectangle') {
                    return true;
                }

                const ap = a.mask.points || [];
                const bp = b.mask.points || [];
                const samples = Math.min(40, Math.max(ap.length, bp.length));

                const testSome = (srcPts, srcShape, dstShape) => {
                    const n = Math.min(samples, srcPts.length);
                    for (let i = 0; i < n; i++) {
                    const p = srcPts[Math.floor((i / n) * srcPts.length)];
                    const [wx, wy] = this._maskPointToWorld(srcShape, p.x, p.y);
                    if (wx >= dstShape.x && wx < dstShape.x + dstShape.width &&
                        wy >= dstShape.y && wy < dstShape.y + dstShape.height) {
                        return true;
                    }
                    }
                    return false;
                };

                return testSome(ap, a, b) || testSome(bp, b, a);
                }

                _maskPointToWorld(shape, px, py) {
                const mw = shape.mask.width  || shape.preRotWidth;
                const mh = shape.mask.height || shape.preRotHeight;

                // scale from mask space to pre-rotation scaled space
                let lx = (shape.preRotWidth  / mw) * px;
                let ly = (shape.preRotHeight / mh) * py;

                // flip
                if (shape.flip === 'h') lx = shape.preRotWidth  - lx;
                if (shape.flip === 'v') ly = shape.preRotHeight - ly;

                // rotate about center
                const cx = shape.preRotWidth / 2, cy = shape.preRotHeight / 2;
                const dx = lx - cx, dy = ly - cy;
                const t = (shape.rotation || 0) * Math.PI / 180;
                const rx = dx * Math.cos(t) - dy * Math.sin(t);
                const ry = dx * Math.sin(t) + dy * Math.cos(t);

                // map to world via the AABB center
                const wx = shape.x + shape.width  / 2 + rx;
                const wy = shape.y + shape.height / 2 + ry;
                return [wx, wy];
                }



                shapesOverlap(shape1, shape2) {
                // Quick reject if separated
                if (
                    shape1.x >= shape2.x + shape2.width ||
                    shape1.x + shape1.width <= shape2.x ||
                    shape1.y >= shape2.y + shape2.height ||
                    shape1.y + shape1.height <= shape2.y
                ) {
                    return false;
                }

                // If masks are missing or rectangular, treat overlapping AABBs as a collision
                if (
                    !shape1.mask || !shape2.mask ||
                    shape1.mask.type === 'rectangle' || shape2.mask.type === 'rectangle' ||
                    !shape1.mask.points || !shape2.mask.points
                ) {
                    return true;
                }

                // Sample-based overlap detection
                const samples = Math.min(20, shape1.mask.points.length);
                for (let i = 0; i < samples; i++) {
                    const point = shape1.mask.points[i];
                    const worldX = shape1.x + point.x;
                    const worldY = shape1.y + point.y;

                    if (
                        worldX >= shape2.x && worldX < shape2.x + shape2.width &&
                        worldY >= shape2.y && worldY < shape2.y + shape2.height
                    ) {
                        return true;
                    }
                }
                return false;
            }
            
                            // Converts mm to device pixels using current DPI
                _mmToPx(mm) {
                return (mm * this.dpi) / 25.4;
                }

                // Build a colored silhouette (solid color masked by the sticker's alpha)
                // at the final drawn size (finalWidth x finalHeight)
                _createColoredSilhouette(sticker, finalWidth, finalHeight, color) {
                // 1) Render the cropped sticker region scaled to final size
                const base = document.createElement('canvas');
                base.width = Math.max(1, Math.floor(finalWidth));
                base.height = Math.max(1, Math.floor(finalHeight));
                const bctx = base.getContext('2d');
                bctx.imageSmoothingEnabled = true;
                bctx.drawImage(
                    sticker.originalImage,
                    sticker.bounds.x, sticker.bounds.y, sticker.bounds.width, sticker.bounds.height,
                    0, 0, base.width, base.height
                );

                // 2) Tint it to the requested color using the alpha mask
                const tint = document.createElement('canvas');
                tint.width = base.width;
                tint.height = base.height;
                const tctx = tint.getContext('2d');
                tctx.drawImage(base, 0, 0);
                tctx.globalCompositeOperation = 'source-in';
                tctx.fillStyle = color;
                tctx.fillRect(0, 0, tint.width, tint.height);
                tctx.globalCompositeOperation = 'source-over';

                return tint; // a solid-color silhouette that follows alpha
                }

                // Stamp silhouette around the sticker at the CURRENT transform
                // outlinePx is thickness in device pixels
                _drawCutlineAtCurrentTransform(ctx, silhouette, finalWidth, finalHeight, outlinePx) {
                const r = Math.max(0, Math.round(outlinePx));
                if (r === 0) return;

                // Unique integer offsets around a circle up to radius r
                const offsets = new Set();

                for (let rad = 1; rad <= r; rad++) {
                    const steps = Math.max(8, Math.round(2 * Math.PI * rad)); // ~one sample per pixel on circumference
                    for (let i = 0; i < steps; i++) {
                    const ang = (i / steps) * 2 * Math.PI;
                    const dx = Math.round(Math.cos(ang) * rad);
                    const dy = Math.round(Math.sin(ang) * rad);
                    offsets.add(dx + ',' + dy);
                    }
                }

                // Draw the silhouette at each offset around the center
                const ox = -finalWidth / 2;
                const oy = -finalHeight / 2;
                for (const key of offsets) {
                    const [dx, dy] = key.split(',').map(Number);
                    ctx.drawImage(silhouette, ox + dx, oy + dy);
                }
                }


            calculateAdvancedFitness(x, y, width, height, placed, intelligence) {
                let fitness = y * 1000 + x; // Base bottom-left preference
                
                if (intelligence >= 4) {
                    // Penalty for wasted space
                    let wastedSpace = 0;
                    for (const other of placed) {
                        const dx = Math.abs((x + width/2) - (other.x + other.finalWidth/2));
                        const dy = Math.abs((y + height/2) - (other.y + other.finalHeight/2));
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        wastedSpace += distance;
                    }
                    fitness += wastedSpace * 0.1;
                }
                
                return fitness;
            }

            getRotatedDimensions(width, height, rotation) {
                return rotation === 90 || rotation === 270 
                    ? { width: height, height: width }
                    : { width, height };
            }

            // Remove the slow occupied space tracking methods
            checkCollision(x, y, width, height, placed, occupied) {
                // Replaced by fastCollisionCheck
                return this.fastCollisionCheck(x, y, width, height, placed);
            }

            markOccupied(occupied, x, y, width, height) {
                // No longer needed - using direct rectangle collision
                return;
            }

            calculatePositionFitness(x, y, width, height, placed) {
                // Prefer bottom-left positions
                return y * 1000 + x;
            }

            renderPackedStickers(includeBackground = true, targetCtx = this.ctx) {
            if (includeBackground) {
                this.drawA4Background(targetCtx);
            } else {
                // transparent export: start with a clear canvas
                targetCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            const marginPx = this._mmToPx(this.margin);

            // cutline controls
            const showCutline = document.getElementById('showCutline')?.checked;
            const cutlineMM = parseFloat(document.getElementById('cutlineWidthMM')?.value || '0');
            const cutlinePx = this._mmToPx(Math.max(0, cutlineMM));
            const cutlineColor = document.getElementById('cutlineColor')?.value || '#ff00ff';

            for (const s of this.packedStickers) {
                targetCtx.save();
                // position to sticker center inside usable area + margin
                targetCtx.translate(marginPx + s.x + s.finalWidth / 2, marginPx + s.y + s.finalHeight / 2);
                targetCtx.rotate((s.rotation || 0) * Math.PI / 180);
                if (s.flip === 'h') targetCtx.scale(-1, 1);
                else if (s.flip === 'v') targetCtx.scale(1, -1);

                if (showCutline && cutlinePx > 0) {
                    let silWidth = s.finalWidth;
                    let silHeight = s.finalHeight;
                    
                    if (s.rotation === 90 || s.rotation === 270) {
                        silWidth = s.finalHeight;
                        silHeight = s.finalWidth;
                    }
                    
                    const silhouette = this._createColoredSilhouette(s, silWidth, silHeight, cutlineColor);
                    this._drawCutlineAtCurrentTransform(targetCtx, silhouette, silWidth, silHeight, cutlinePx);
                }

               // 2) Sticker image - maintain aspect ratio for rotations
                let drawWidth = s.finalWidth;
                let drawHeight = s.finalHeight;

                // For 90° and 270° rotations, the final dimensions are swapped
                // but we need to draw at the original aspect ratio
                if (s.rotation === 90 || s.rotation === 270) {
                    drawWidth = s.finalHeight;
                    drawHeight = s.finalWidth;
                }

                targetCtx.drawImage(
                    s.originalImage,
                    s.bounds.x, s.bounds.y, s.bounds.width, s.bounds.height,
                    -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight
                );

                targetCtx.restore();
            }
            }



            calculateEfficiency() {
                if (this.packedStickers.length === 0) return;

                const marginPx = (this.margin * this.dpi) / 25.4;
                const totalArea = (this.canvas.width - 2 * marginPx) * (this.canvas.height - 2 * marginPx);
                const usedArea = this.packedStickers.reduce((sum, sticker) => 
                    sum + (sticker.finalWidth * sticker.finalHeight), 0);

                const efficiency = Math.round((usedArea / totalArea) * 100);
                
                document.getElementById('efficiencyText').textContent = `${efficiency}%`;
                document.getElementById('efficiencyFill').style.width = `${efficiency}%`;
            }

            getStickerHeightMM(stickerId) {
                const input = document.querySelector(`input[onchange*="${stickerId}"]`);
                return input ? parseFloat(input.value) : 30;
            }

            updateStatus(message, type = 'info') {
                const statusEl = document.getElementById('statusMessage');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
            }

            downloadPNG() {
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = this.canvas.width;
                exportCanvas.height = this.canvas.height;
                const ectx = exportCanvas.getContext('2d');

                const transparentWanted = document.getElementById('transparentExport')?.checked;

                if (transparentWanted) {
                    // Transparent: render stickers only (no background/guides)
                    this.renderPackedStickers(false, ectx);
                } else {
                    // Opaque: draw like the preview
                    this.renderPackedStickers(true, ectx);
                }

                const link = document.createElement('a');
                link.download = `sticker-sheet-${this.dpi}dpi-${Date.now()}.png`;
                link.href = exportCanvas.toDataURL('image/png');
                link.click();
            }


            clearAll() {
                this.stickers = [];
                this.packedStickers = [];
                document.getElementById('stickersList').innerHTML = '';
                document.getElementById('stickerFiles').value = '';
                document.getElementById('downloadBtn').disabled = true;
                this.drawA4Background();
                this.updateStatus('Ready to load new stickers', 'info');
                document.getElementById('efficiencyText').textContent = '0%';
                document.getElementById('efficiencyFill').style.width = '0%';
            }
        }

        // Global functions
        let packer;

        function updateStickerSize(stickerId, heightMM) {
            // This function is called when sticker height is changed
            console.log(`Updated sticker ${stickerId} height to ${heightMM}mm`);
        }

        function packStickers() {
            packer.packStickers();
        }

        function clearAll() {
            packer.clearAll();
        }

        function removeSticker(stickerId) {
            const index = packer.stickers.findIndex(s => s.id === stickerId);
            if (index !== -1) {
                packer.stickers.splice(index, 1);
                document.getElementById(`sticker-item-${stickerId}`).remove();
                packer.updateStatus(`Removed sticker from inventory`, 'info');
                
                // Clear packed stickers since inventory changed
                packer.packedStickers = [];
                packer.drawA4Background();
                document.getElementById('downloadBtn').disabled = true;
            }
        }

        function adjustQuantity(stickerId, change) {
            const sticker = packer.stickers.find(s => s.id === stickerId);
            if (sticker) {
                sticker.quantity = Math.max(1, (sticker.quantity || 1) + change);
                packer.updateStickerInList(sticker);
                
                // Clear packed stickers since quantities changed
                packer.packedStickers = [];
                packer.drawA4Background();
                document.getElementById('downloadBtn').disabled = true;
            }
        }

        function clearAllStickers() {
            packer.stickers = [];
            packer.packedStickers = [];
            document.getElementById('stickersList').innerHTML = '';
            document.getElementById('stickerFiles').value = '';
            document.getElementById('downloadBtn').disabled = true;
            packer.drawA4Background();
            packer.updateStatus('Cleared all stickers from inventory', 'info');
            document.getElementById('efficiencyText').textContent = '0%';
            document.getElementById('efficiencyFill').style.width = '0%';
        }

        function downloadPNG() {
            packer.downloadPNG();
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            packer = new StickerPacker();
        });
    </script>
</body>
</html>